#![crate_type = "cdylib"]
#![no_std]

const PRIME_X: i64 = 0x5205402B9270C86F;
const PRIME_Y: i64 = 0x598CD327003817B5;
const HASH_MULTIPLIER: i64 = 0x53A3F72DEEC546F5;
const SKEW_2D: f64 = 0.366025403784439;
const UNSKEW_2D: f64 = -0.21132486540518713;
const RSQUARED_2D: f64 = 2.0 / 3.0;

#[no_mangle]
pub extern "C" fn open_simplex_2_noise_octaves(
    seed: i32,
    x: f64,
    y: f64,
    mut frequency: f64,
    octaves: u32,
    lacunarity: f64,
    gain: f64
) -> f64 {
    let mut sum = 0.0;
    let mut amplitude = 1.0;
    let mut total_amplitude = 0.0;

    for i in 0..octaves {
        let scaled = open_simplex_2_noise_scaled(seed + i as i32, x, y, frequency);
        sum += scaled * amplitude;
        total_amplitude += amplitude;
        frequency *= lacunarity;
        amplitude *= gain;
    }
    sum / total_amplitude
}

#[no_mangle]
pub extern "C" fn open_simplex_2_noise_scaled(seed: i32, x: f64, y: f64, frequency: f64) -> f64 {
    open_simplex_2_noise(seed, x * frequency, y * frequency)
}

/**
    2D OpenSimplex2S/SuperSimplex noise, standard lattice orientation.
*/
#[no_mangle]
pub extern "C" fn open_simplex_2_noise(seed: i32, x: f64, y: f64) -> f64 {
    // Get points for A2* lattice
    let s = SKEW_2D * (x + y);
    let xs = x + s;
    let ys = y + s;

    normalize(open_simplex_2_noise_unskewed_base(seed.into(), xs, ys))
}

#[inline]
pub fn normalize(v: f64) -> f64 {
    return (v + 1.0) * 0.5;
}

/**
    2D  OpenSimplex2S/SuperSimplex noise base.
*/
fn open_simplex_2_noise_unskewed_base(seed: i64, xs: f64, ys: f64) -> f64 {

    // Get base points and offsets.
    let xsb = fast_floor(xs);
    let ysb = fast_floor(ys);
    let xi = xs - xsb as f64;
    let yi = ys - ysb as f64;

    // Prime pre-multiplication for hash.
    let xsbp = xsb.wrapping_mul(PRIME_X);
    let ysbp = ysb.wrapping_mul(PRIME_Y);

    // Unskew.
    let t = (xi + yi) * UNSKEW_2D;
    let dx0 = xi + t;
    let dy0 = yi + t;

    // First vertex.
    let a0 = 2.0/3.0 - dx0 * dx0 - dy0 * dy0;
    let mut value = (a0 * a0) * (a0 * a0) * grad2(seed, xsbp, ysbp, dx0, dy0);

    // Second vertex.
    let a1 = (2.0 * (1.0 + 2.0 * UNSKEW_2D) * (1.0 / UNSKEW_2D + 2.0)) * t
        + ((-2.0 * (1.0 + 2.0 * UNSKEW_2D) * (1.0 + 2.0 * UNSKEW_2D)) + a0);
    let dx1 = dx0 - (1.0 + 2.0 * UNSKEW_2D);
    let dy1 = dy0 - (1.0 + 2.0 * UNSKEW_2D);
    value += (a1 * a1) * (a1 * a1) * grad2(seed, xsbp.wrapping_add(PRIME_X), ysbp.wrapping_add(PRIME_Y), dx1, dy1);

    // Third and fourth vertices.
    // Nested conditionals were faster than compact bit logic/arithmetic.
    let xmyi = xi - yi;
    if t < UNSKEW_2D {
        if xi + xmyi > 1.0 {
            let dx2 = dx0 - (3.0 * UNSKEW_2D + 2.0);
            let dy2 = dy0 - (3.0 * UNSKEW_2D + 1.0);
            let a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if a2 > 0.0 {
                value += (a2 * a2) * (a2 * a2) * grad2(seed, xsbp.wrapping_add(PRIME_X << 1), ysbp.wrapping_add(PRIME_Y), dx2, dy2);
            }
        } else {
            let dx2 = dx0 - UNSKEW_2D;
            let dy2 = dy0 - (UNSKEW_2D + 1.0);
            let a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if a2 > 0.0 {
                value += (a2 * a2) * (a2 * a2) * grad2(seed, xsbp, ysbp.wrapping_add(PRIME_Y), dx2, dy2);
            }
        }

        if yi - xmyi > 1.0 {
            let dx3 = dx0 - (3.0 * UNSKEW_2D + 1.0);
            let dy3 = dy0 - (3.0 * UNSKEW_2D + 2.0);
            let a3 = RSQUARED_2D - dx3 * dx3 - dy3 * dy3;
            if a3 > 0.0 {
                value += (a3 * a3) * (a3 * a3) * grad2(seed, xsbp.wrapping_add(PRIME_X), ysbp.wrapping_add(PRIME_Y << 1), dx3, dy3);
            }
        } else {
            let dx3 = dx0 - (UNSKEW_2D + 1.0);
            let dy3 = dy0 - UNSKEW_2D;
            let a3 = RSQUARED_2D - dx3 * dx3 - dy3 * dy3;
            if a3 > 0.0 {
                value += (a3 * a3) * (a3 * a3) * grad2(seed, xsbp.wrapping_add(PRIME_X), ysbp, dx3, dy3);
            }
        }
    } else {
        if xi + xmyi < 0.0 {
            let dx2 = dx0 + (1.0 + UNSKEW_2D);
            let dy2 = dy0 + UNSKEW_2D;
            let a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if a2 > 0.0 {
                value += (a2 * a2) * (a2 * a2) * grad2(seed, xsbp.wrapping_sub(PRIME_X), ysbp, dx2, dy2);
            }
        } else {
            let dx2 = dx0 - (UNSKEW_2D + 1.0);
            let dy2 = dy0 - UNSKEW_2D;
            let a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if a2 > 0.0 {
                value += (a2 * a2) * (a2 * a2) * grad2(seed, xsbp.wrapping_add(PRIME_X), ysbp, dx2, dy2);
            }
        }
        if yi < xmyi {
            let dx2 = dx0 + UNSKEW_2D;
            let dy2 = dy0 + (UNSKEW_2D + 1.0);
            let a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if a2 > 0.0 {
                value += (a2 * a2) * (a2 * a2) * grad2(seed, xsbp, ysbp.wrapping_sub(PRIME_Y), dx2, dy2);
            }
        } else {
            let dx2 = dx0 - UNSKEW_2D;
            let dy2 = dy0 - (UNSKEW_2D + 1.0);
            let a2 = RSQUARED_2D - dx2 * dx2 - dy2 * dy2;
            if a2 > 0.0 {
                value += (a2 * a2) * (a2 * a2) * grad2(seed, xsbp, ysbp.wrapping_add(PRIME_Y), dx2, dy2);
            }
        }
    }
    value
}

const N_GRADS_2D_SHIFT: u32 = 58;
const N_GRADS_2D_MASK: i32 = 254;

fn grad2(seed: i64, xsvp: i64, ysvp: i64, dx: f64, dy: f64) -> f64 {
    let mut hash = seed ^ xsvp ^ ysvp;
    hash = hash.wrapping_mul(HASH_MULTIPLIER);
    hash = hash ^ hash.wrapping_shr(N_GRADS_2D_SHIFT);
    let gi = (hash as i32 & N_GRADS_2D_MASK) as usize;
    GRADIENTS_2D[gi | 0] * dx + GRADIENTS_2D[gi | 1] * dy
}

static GRADIENTS_2D: [f64; 256] = [
    6.980896610132626, 16.853375273706543, 16.853375273706543, 6.980896610132626, 
    16.853375273706543, -6.980896610132626, 6.980896610132626, -16.853375273706543, 
    -6.980896610132626, -16.853375273706543, -16.853375273706543, -6.980896610132626, 
    -16.853375273706543, 6.980896610132626, -6.980896610132626, 16.853375273706543, 
    2.3810538312857545, 18.085899431608684, 11.105002821476075, 14.472321442420789, 
    14.472321442420789, 11.105002821476075, 18.085899431608684, 2.3810538312857363, 
    18.085899431608684, -2.3810538312857363, 14.472321442420789, -11.105002821476058, 
    11.105002821476075, -14.472321442420789, 2.3810538312857545, -18.085899431608684, 
    -2.3810538312857545, -18.085899431608684, -11.105002821476075, -14.472321442420789, 
    -14.472321442420789, -11.105002821476075, -18.085899431608684, -2.3810538312857545, 
    -18.085899431608684, 2.3810538312857363, -14.472321442420789, 11.105002821476075, 
    -11.105002821476075, 14.472321442420789, -2.3810538312857545, 18.085899431608684, 
    6.980896610132626, 16.853375273706543, 16.853375273706543, 6.980896610132626, 
    16.853375273706543, -6.980896610132626, 6.980896610132626, -16.853375273706543, 
    -6.980896610132626, -16.853375273706543, -16.853375273706543, -6.980896610132626, 
    -16.853375273706543, 6.980896610132626, -6.980896610132626, 16.853375273706543, 
    2.3810538312857545, 18.085899431608684, 11.105002821476075, 14.472321442420789, 
    14.472321442420789, 11.105002821476075, 18.085899431608684, 2.3810538312857363, 
    18.085899431608684, -2.3810538312857363, 14.472321442420789, -11.105002821476058, 
    11.105002821476075, -14.472321442420789, 2.3810538312857545, -18.085899431608684, 
    -2.3810538312857545, -18.085899431608684, -11.105002821476075, -14.472321442420789, 
    -14.472321442420789, -11.105002821476075, -18.085899431608684, -2.3810538312857545, 
    -18.085899431608684, 2.3810538312857363, -14.472321442420789, 11.105002821476075, 
    -11.105002821476075, 14.472321442420789, -2.3810538312857545, 18.085899431608684, 
    6.980896610132626, 16.853375273706543, 16.853375273706543, 6.980896610132626, 
    16.853375273706543, -6.980896610132626, 6.980896610132626, -16.853375273706543, 
    -6.980896610132626, -16.853375273706543, -16.853375273706543, -6.980896610132626, 
    -16.853375273706543, 6.980896610132626, -6.980896610132626, 16.853375273706543, 
    2.3810538312857545, 18.085899431608684, 11.105002821476075, 14.472321442420789, 
    14.472321442420789, 11.105002821476075, 18.085899431608684, 2.3810538312857363, 
    18.085899431608684, -2.3810538312857363, 14.472321442420789, -11.105002821476058, 
    11.105002821476075, -14.472321442420789, 2.3810538312857545, -18.085899431608684, 
    -2.3810538312857545, -18.085899431608684, -11.105002821476075, -14.472321442420789, 
    -14.472321442420789, -11.105002821476075, -18.085899431608684, -2.3810538312857545, 
    -18.085899431608684, 2.3810538312857363, -14.472321442420789, 11.105002821476075, 
    -11.105002821476075, 14.472321442420789, -2.3810538312857545, 18.085899431608684, 
    6.980896610132626, 16.853375273706543, 16.853375273706543, 6.980896610132626, 
    16.853375273706543, -6.980896610132626, 6.980896610132626, -16.853375273706543, 
    -6.980896610132626, -16.853375273706543, -16.853375273706543, -6.980896610132626, 
    -16.853375273706543, 6.980896610132626, -6.980896610132626, 16.853375273706543, 
    2.3810538312857545, 18.085899431608684, 11.105002821476075, 14.472321442420789, 
    14.472321442420789, 11.105002821476075, 18.085899431608684, 2.3810538312857363, 
    18.085899431608684, -2.3810538312857363, 14.472321442420789, -11.105002821476058, 
    11.105002821476075, -14.472321442420789, 2.3810538312857545, -18.085899431608684, 
    -2.3810538312857545, -18.085899431608684, -11.105002821476075, -14.472321442420789, 
    -14.472321442420789, -11.105002821476075, -18.085899431608684, -2.3810538312857545, 
    -18.085899431608684, 2.3810538312857363, -14.472321442420789, 11.105002821476075, 
    -11.105002821476075, 14.472321442420789, -2.3810538312857545, 18.085899431608684, 
    6.980896610132626, 16.853375273706543, 16.853375273706543, 6.980896610132626, 
    16.853375273706543, -6.980896610132626, 6.980896610132626, -16.853375273706543, 
    -6.980896610132626, -16.853375273706543, -16.853375273706543, -6.980896610132626, 
    -16.853375273706543, 6.980896610132626, -6.980896610132626, 16.853375273706543, 
    2.3810538312857545, 18.085899431608684, 11.105002821476075, 14.472321442420789, 
    14.472321442420789, 11.105002821476075, 18.085899431608684, 2.3810538312857363, 
    18.085899431608684, -2.3810538312857363, 14.472321442420789, -11.105002821476058, 
    11.105002821476075, -14.472321442420789, 2.3810538312857545, -18.085899431608684, 
    -2.3810538312857545, -18.085899431608684, -11.105002821476075, -14.472321442420789, 
    -14.472321442420789, -11.105002821476075, -18.085899431608684, -2.3810538312857545, 
    -18.085899431608684, 2.3810538312857363, -14.472321442420789, 11.105002821476075, 
    -11.105002821476075, 14.472321442420789, -2.3810538312857545, 18.085899431608684, 
    6.980896610132626, 16.853375273706543, 16.853375273706543, 6.980896610132626, 
    16.853375273706543, -6.980896610132626, 6.980896610132626, -16.853375273706543, 
    -6.980896610132626, -16.853375273706543, -16.853375273706543, -6.980896610132626, 
    -16.853375273706543, 6.980896610132626, -6.980896610132626, 16.853375273706543
];

fn fast_floor(x: f64) -> i64 {
    let xi = x as i64;
    if x < xi as f64 {
        xi - 1
    } else {
        xi
    }
}

#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    core::arch::wasm32::unreachable()
}
